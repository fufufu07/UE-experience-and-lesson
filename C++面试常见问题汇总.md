# C++ 面试常见问题汇总

> 2025-2026 年高频面试题精选，力求回答精准

---

## 一、C++ 基础与语法

### 1. C 和 C++ 的区别？
- C++ 是 C 的超集，增加了**类、面向对象（封装/继承/多态）、STL、命名空间、异常处理、运算符重载**等特性

### 2. static 关键字的作用？
- **C语言**：修饰局部变量延长生命周期；修饰全局变量/函数限制作用域为本文件
- **C++**：额外可修饰**类静态成员**，属于类本身，所有对象共享

### 3. #define 和 const 的区别？
| #define | const |
|---------|-------|
| 预处理阶段文本替换 | 编译期处理，有类型检查 |
| 无作用域 | 有作用域 |
| 不支持调试 | 支持调试 |

### 4. sizeof 与 strlen 的区别？
- `sizeof`：编译期获取类型/变量**大小（字节）**
- `strlen`：运行时获取字符串**长度**（遇 `\0` 截止）

---

## 二、内存管理与指针引用

### 1. malloc/free 与 new/delete 的区别？
| malloc/free | new/delete |
|-------------|------------|
| C 函数库 | C++ 运算符 |
| 不调用构造/析构函数 | 自动调用构造/析构函数 |
| 返回 void*，需强转 | 返回具体类型指针 |
| 失败返回 NULL | 失败抛异常（可用 nothrow） |

### 2. 智能指针有哪些？使用场景？
```cpp
unique_ptr<T>   // 独占所有权，不可拷贝
shared_ptr<T>   // 引用计数共享，多所有者场景
weak_ptr<T>     // 配合 shared_ptr 解决循环引用
```

### 3. 指针与引用的区别？
| 指针 | 引用 |
|------|------|
| 可为空、可变、可多级 | 必须初始化、不可变 |
| 需解引用访问 | 语法简洁直接访问 |
| 占用额外内存 | 通常不占额外空间 |

### 4. 什么是野指针/悬挂指针？如何避免？
- **野指针**：未初始化的指针
- **悬挂指针**：指向已释放内存的指针
- **避免方法**：初始化为 nullptr，释放后置空，优先使用智能指针

---

## 三、面向对象与多态

### 1. 面向对象三大特性？
- **封装**：隐藏实现细节，提供接口
- **继承**：代码复用，建立层次关系
- **多态**：运行时动态行为，接口统一

### 2. 重载(Overload)和重写(Override)的区别？
| 重载 | 重写 |
|------|------|
| 同一类中，函数名相同参数不同 | 派生类重写基类虚函数 |
| 编译期多态 | 运行期多态 |

### 3. 虚函数实现原理？
- 每个含虚函数的类有一个**虚函数表(vtable)**
- 对象中有**虚表指针(vptr)**指向虚函数表
- 调用虚函数时通过虚表指针动态查找

### 4. 为什么基类析构函数要声明为虚函数？
```cpp
Base* p = new Derived();
delete p;  // 若析构非虚，只调用 Base::~Base()，Derived 资源泄漏！
```

### 5. 四种类型转换？
```cpp
static_cast<T>()      // 基本类型转换、父子类指针转换（无运行时检查）
dynamic_cast<T>()     // 多态类型安全转换（有运行时检查）
const_cast<T>()       // 去除/添加 const 属性
reinterpret_cast<T>() // 底层位模式重新解释（危险）
```

---

## 四、STL 与现代 C++ 特性

### 1. vector 与 list 的区别？
| vector | list |
|--------|------|
| 底层数组，支持随机访问 | 双向链表，不支持随机访问 |
| 尾部增删 O(1)，中间 O(n) | 任意位置增删 O(1) |
| 内存连续，缓存友好 | 内存分散，每节点额外开销 |

### 2. vector 扩容机制？
- 容量不足时**成倍扩容**（通常 1.5x 或 2x）
- 原内存元素**拷贝/移动**到新内存
- **迭代器失效**，需重新获取

### 3. map 与 unordered_map 的区别？
| map | unordered_map |
|-----|---------------|
| 底层红黑树，有序 | 底层哈希表，无序 |
| 查找 O(log n) | 平均 O(1)，最差 O(n) |

### 4. emplace_back 与 push_back 的区别？
```cpp
vec.push_back(T(args));   // 先构造临时对象，再拷贝/移动
vec.emplace_back(args);   // 原地构造，避免额外拷贝，性能更优
```

### 5. 右值引用与移动语义？
```cpp
std::string&& rref = std::move(str);  // 右值引用
// 移动语义：转移资源所有权，避免深拷贝，提升性能
```

### 6. Lambda 表达式？
```cpp
auto func = [capture](params) -> ret_type { body };
// [=] 值捕获所有  [&] 引用捕获所有  [x, &y] 混合捕获
```

---

## 五、并发与多线程

### 1. 互斥锁与读写锁的区别？
| 互斥锁 (mutex) | 读写锁 (shared_mutex) |
|----------------|----------------------|
| 所有访问互斥 | 读可并发，写互斥 |
| 适合读写均衡 | 适合读多写少场景 |

### 2. 什么是死锁？如何避免？
- **死锁条件**：互斥、持有并等待、不可剥夺、循环等待
- **避免方法**：
  - 固定加锁顺序
  - 使用 `std::lock()` 同时锁多个
  - 使用 `std::scoped_lock` (C++17)

### 3. 原子操作与 CAS？
```cpp
std::atomic<int> count{0};
count.fetch_add(1);  // 原子加
// CAS: Compare-And-Swap，无锁编程基础
```

---

## 六、常见编程题（手撕代码）

1. **实现智能指针**（shared_ptr 引用计数）
2. **实现单例模式**（线程安全）
3. **实现字符串类**（深拷贝、移动语义）
4. **链表操作**：反转、环检测、合并有序链表
5. **排序算法**：快排、归并、堆排（时间复杂度分析）
6. **二分查找及变种**
7. **生产者消费者模型**

---

## 七、经典陷阱题

### 1. 以下代码有什么问题？
```cpp
char* func() {
    char str[] = "hello";
    return str;  // ❌ 返回局部数组地址，悬挂指针！
}
```

### 2. 浅拷贝 vs 深拷贝？
- **浅拷贝**：只复制指针，多个对象共享同一资源 → 析构时 double free
- **深拷贝**：复制指针指向的内容 → 安全但开销大

### 3. 虚函数能否声明为内联？
- 可以声明，但**多态调用时无法内联**（因为运行时才确定调用哪个函数）

---

## 面试技巧建议

- **基础扎实**：内存管理、多态原理是必考
- **结合项目**：能说明技术选型和性能优化实践
- **手写代码**：注意边界条件、内存安全
- **C++11/14/17 新特性**：智能指针、Lambda、移动语义、并发库是加分项