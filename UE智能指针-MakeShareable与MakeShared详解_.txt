# UE智能指针：MakeShareable 与 MakeShared 详解

## 目录
- [基本概念](#基本概念)
- [主要区别](#主要区别)
- [自定义删除器](#自定义删除器)
- [设计原理](#设计原理)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

---

## 基本概念

Unreal Engine 提供了两个用于创建智能指针的主要函数：
- `MakeShared<T>()` - 创建新对象并返回智能指针
- `MakeShareable()` - 将已存在的原始指针包装为智能指针

---

## 主要区别

### 1. MakeShared

**功能**：创建一个新对象并返回 `TSharedPtr`

**特点**：
- 对象和引用计数控制块在**单次内存分配**中完成
- 性能更优，内存局部性更好
- **不支持自定义删除器**
- 推荐优先使用

**语法**：
```cpp
TSharedPtr<MyClass> Ptr = MakeShared<MyClass>(构造参数);
```

**示例**：
```cpp
// 基本使用
TSharedPtr<FMyClass> MyPtr = MakeShared<FMyClass>();

// 带构造参数
TSharedPtr<FPlayerData> PlayerPtr = MakeShared<FPlayerData>(PlayerName, Level);

// 使用 auto
auto ActorPtr = MakeShared<AActor>();
```

**内存布局**：
```
+--------------------------------+
| 引用计数控制块                   |
| - SharedRefCount               |
| - WeakRefCount                 |
+--------------------------------+
| 实际对象 (MyClass)              |
| - 成员变量                      |
+--------------------------------+
    ↑
单次连续内存分配
```

---

### 2. MakeShareable

**功能**：将已存在的原始指针包装成 `TSharedPtr`

**特点**：
- 对象已经存在，只创建引用计数控制块
- 两次内存分配（对象 + 控制块）
- **支持自定义删除器**
- 仅在必要时使用

**语法**：
```cpp
TSharedPtr<MyClass> Ptr = MakeShareable(RawPtr);
TSharedPtr<MyClass> Ptr = MakeShareable(RawPtr, CustomDeleter);
```

**示例**：
```cpp
// 基本使用
FMyClass* RawPtr = new FMyClass(Param1, Param2);
TSharedPtr<FMyClass> MyPtr = MakeShareable(RawPtr);

// 带自定义删除器
FILE* File = fopen("data.txt", "r");
TSharedPtr<FILE> FilePtr = MakeShareable(File, [](FILE* f) { 
    fclose(f); 
});
```

**内存布局**：
```
[对象内存]
+------------------+
| MyClass 对象      |
+------------------+

[控制块内存] (单独分配)
+------------------+
| 引用计数控制块    |
| - 指向对象的指针  |
| - 删除器（可选）  |
+------------------+
```

---

### 对比表

| 特性 | MakeShared | MakeShareable |
|------|------------|---------------|
| **创建新对象** | ✅ 是 | ❌ 否（使用已存在对象） |
| **内存分配次数** | 1次 | 2次 |
| **内存效率** | 更高 | 较低 |
| **性能** | 更好 | 稍差 |
| **自定义删除器** | ❌ 不支持 | ✅ 支持 |
| **推荐程度** | ⭐⭐⭐⭐⭐ 首选 | ⭐⭐⭐ 特殊场景使用 |

---

## 自定义删除器

### 支持情况

```cpp
// ❌ MakeShared 不支持自定义删除器
// TSharedPtr<MyClass> Ptr = MakeShared<MyClass>(CustomDeleter); // 编译错误

// ✅ MakeShareable 支持自定义删除器
MyClass* RawPtr = new MyClass();
TSharedPtr<MyClass> Ptr = MakeShareable(RawPtr, CustomDeleter);
```

### 使用方式

#### 1. 函数指针删除器

```cpp
void MyCustomDeleter(MyClass* Ptr)
{
    UE_LOG(LogTemp, Warning, TEXT("Custom deleter called"));
    // 执行清理逻辑
    Ptr->Cleanup();
    delete Ptr;
}

MyClass* RawPtr = new MyClass();
TSharedPtr<MyClass> SharedPtr = MakeShareable(RawPtr, &MyCustomDeleter);
```

#### 2. Lambda 表达式删除器

```cpp
MyClass* RawPtr = new MyClass();
TSharedPtr<MyClass> SharedPtr = MakeShareable(RawPtr, [](MyClass* Ptr)
{
    UE_LOG(LogTemp, Warning, TEXT("Lambda deleter called"));
    Ptr->OnDestroy();
    delete Ptr;
});
```

#### 3. Functor 删除器

```cpp
struct FMyDeleter
{
    void operator()(MyClass* Ptr) const
    {
        UE_LOG(LogTemp, Log, TEXT("Functor deleter:  %s"), *Ptr->GetName());
        delete Ptr;
    }
};

MyClass* RawPtr = new MyClass();
TSharedPtr<MyClass> SharedPtr = MakeShareable(RawPtr, FMyDeleter());
```

### 实际应用场景

#### 场景 1：管理数组

```cpp
// 错误：普通 delete 无法正确释放数组
int32* Array = new int32[100];
// TSharedPtr<int32> ArrayPtr = MakeShareable(Array); // ❌ 内存泄漏

// 正确：使用 delete[] 删除器
TSharedPtr<int32> ArrayPtr = MakeShareable(Array, [](int32* Ptr)
{
    delete[] Ptr;
});
```

#### 场景 2：集成 C API

```cpp
// 管理 FILE* 指针
FILE* File = fopen("config.ini", "r");
if (File)
{
    TSharedPtr<FILE> FilePtr = MakeShareable(File, [](FILE* f)
    {
        if (f)
        {
            fclose(f);
            UE_LOG(LogTemp, Log, TEXT("File closed"));
        }
    });
    
    // 使用 FilePtr... 
}
```

#### 场景 3：对象池管理

```cpp
class FObjectPool
{
public:
    TSharedPtr<FPooledObject> Acquire()
    {
        FPooledObject* Obj = Pool.Pop();
        
        // 返回智能指针时，使用自定义删除器将对象归还池中
        return MakeShareable(Obj, [this](FPooledObject* Ptr)
        {
            // 不删除，而是归还到池中
            Pool. Push(Ptr);
            UE_LOG(LogTemp, Log, TEXT("Object returned to pool"));
        });
    }
    
private:
    TArray<FPooledObject*> Pool;
};
```

#### 场景 4：栈对象或无需删除的对象

```cpp
void ProcessData()
{
    FMyData StackObject;
    
    // 传递给需要 TSharedPtr 的接口，但不真正删除
    TSharedPtr<FMyData> Ptr = MakeShareable(&StackObject, [](FMyData* p)
    {
        // 空删除器，不执行任何操作
    });
    
    SomeFunction(Ptr);
    
    // StackObject 在函数结束时自动销毁
}
```

#### 场景 5：特殊清理逻辑

```cpp
class FResourceManager
{
public:
    static TSharedPtr<FTextureResource> LoadTexture(const FString& Path)
    {
        FTextureResource* Resource = new FTextureResource(Path);
        
        return MakeShareable(Resource, [](FTextureResource* Ptr)
        {
            // 先卸载资源
            if (Ptr->IsLoaded())
            {
                Ptr->Unload();
                UE_LOG(LogTemp, Log, TEXT("Texture unloaded:  %s"), *Ptr->GetPath());
            }
            
            // 从管理器注销
            FResourceManager:: Unregister(Ptr);
            
            // 最后删除对象
            delete Ptr;
        });
    }
};
```

---

## 设计原理

### 为什么 MakeShared 不支持自定义删除器？

#### 1. 内存布局的限制

**MakeShared 的优化**：
```cpp
// MakeShared 将控制块和对象放在一起
template<typename T, typename... Args>
TSharedPtr<T> MakeShared(Args&&... args)
{
    // 伪代码示意
    void* Memory = Allocate(sizeof(ControlBlock) + sizeof(T));
    ControlBlock* Control = new (Memory) ControlBlock();
    T* Object = new (Memory + sizeof(ControlBlock)) T(Forward<Args>(args)...);
    return TSharedPtr<T>(Object, Control);
}
```

**问题**：
- 对象类型 `T` 的大小在编译期确定
- 删除器类型可能不同：`lambda`（捕获大小不定）、函数指针、functor 等
- 控制块大小无法在编译期确定
- 破坏了单次分配的优化

**MakeShareable 的灵活性**：
```cpp
// MakeShareable 分离对象和控制块
template<typename T, typename DeleterType>
TSharedPtr<T> MakeShareable(T* Ptr, DeleterType&& Deleter)
{
    // 控制块大小可以根据删除器动态调整
    auto* Control = new ControlBlockWithDeleter<T, DeleterType>(Ptr, Forward<DeleterType>(Deleter));
    return TSharedPtr<T>(Ptr, Control);
}
```

#### 2. 性能 vs 灵活性的权衡

```cpp
// 统计：99% 的场景不需要自定义删除器
// ✅ 为这 99% 优化性能
TSharedPtr<MyClass> Ptr1 = MakeShared<MyClass>();
// - 一次内存分配
// - 更好的缓存局部性
// - 更少的内存碎片
// - 更快的分配/释放速度

// 1% 的场景需要自定义删除器
// ✅ 提供灵活的 MakeShareable
MyClass* Raw = new MyClass();
TSharedPtr<MyClass> Ptr2 = MakeShareable(Raw, CustomDeleter);
// - 两次内存分配
// - 支持任意删除器
// - 性能略有下降，但可接受
```

#### 3. 类型擦除的复杂性

```cpp
// 假设 MakeShared 支持删除器（实际不支持）
auto Ptr1 = MakeShared<MyClass>([x=42](MyClass* p) { /* ... */ delete p; });  // Lambda 捕获
auto Ptr2 = MakeShared<MyClass>(&FreeFunction);                                // 函数指针
auto Ptr3 = MakeShared<MyClass>(BigFunctor{});                                 // 大型 Functor

// 问题：这三个智能指针的控制块大小完全不同！
// sizeof(ControlBlock1) = Base + sizeof(Lambda with capture)
// sizeof(ControlBlock2) = Base + sizeof(function pointer)
// sizeof(ControlBlock3) = Base + sizeof(BigFunctor)

// 解决方案需要：
// - 复杂的模板元编程
// - 额外的类型擦除开销
// - 更大的代码体积
// - 可能的运行时性能损失
```

#### 4. 与 C++ 标准库的一致性

```cpp
// C++ 标准库也有相同的设计
// std::make_shared 不支持删除器
auto ptr1 = std::make_shared<MyClass>();  // ✅

// ❌ 不能这样做
// auto ptr2 = std::make_shared<MyClass>(custom_deleter);

// ✅ 必须使用构造函数
std::shared_ptr<MyClass> ptr3(new MyClass(), custom_deleter);

// UE 遵循相同的设计哲学
```

### Epic 的设计哲学

#### 1. 性能优先（Performance First）

```cpp
// 游戏引擎的核心需求：每帧可能创建/销毁数千个对象
void AMyActor:: Tick(float DeltaTime)
{
    // 这种代码每帧执行，性能至关重要
    for (int32 i = 0; i < 1000; ++i)
    {
        TSharedPtr<FParticle> Particle = MakeShared<FParticle>();
        Particles.Add(Particle);
    }
}

// 优化最常见的路径比支持罕见的特性更重要
```

#### 2. 明确的语义（Clear Semantics）

```cpp
// MakeShared：我创建并完全管理这个对象
TSharedPtr<MyClass> Ptr1 = MakeShared<MyClass>();
// 含义：标准的创建和销毁，无特殊逻辑

// MakeShareable：我接管已存在的对象（可能有特殊需求）
MyClass* Raw = AcquireFromSomewhere();
TSharedPtr<MyClass> Ptr2 = MakeShareable(Raw, SpecialDeleter);
// 含义：这个对象有特殊的生命周期管理需求
```

#### 3. 避免意外的性能成本（No Hidden Costs）

```cpp
// 如果 MakeShared 支持删除器，可能导致意外的性能下降
// 用户可能无意中写出低效代码：

// 看起来很普通的 MakeShared
TArray<uint8> LargeData;  // 假设 1MB
auto Ptr = MakeShared<MyClass>([LargeData](MyClass* p) {  // ⚠️ 捕获了 1MB 数据！
    // ... 
    delete p;
});

// 问题：
// 1. 控制块现在包含 1MB 的捕获数据
// 2. 即使对象本身很小，也会有巨大的内存开销
// 3. 用户可能不知道这个隐藏的成本

// 现在的设计强制使用 MakeShareable，让特殊情况更明显：
auto Ptr = MakeShareable(new MyClass(), [LargeData](MyClass* p) {
    // 仍然有问题，但至少代码明确表明这是特殊情况
    delete p;
});
```

### 性能对比

```cpp
// 基准测试（简化示意）
void BenchmarkMakeShared()
{
    // MakeShared:  ~20ns per allocation
    for (int i = 0; i < 1000000; ++i)
    {
        auto Ptr = MakeShared<FMyClass>();
    }
}

void BenchmarkMakeShareable()
{
    // MakeShareable: ~35ns per allocation (包含 new + 控制块)
    for (int i = 0; i < 1000000; ++i)
    {
        auto Ptr = MakeShareable(new FMyClass());
    }
}

void BenchmarkMakeShareableWithDeleter()
{
    // MakeShareable + Deleter: ~40ns per allocation
    for (int i = 0; i < 1000000; ++i)
    {
        auto Ptr = MakeShareable(new FMyClass(), [](FMyClass* p) { delete p; });
    }
}

// 在每帧运行的游戏代码中，15-20ns 的差异会累积
```

---

## 最佳实践

### ✅ 推荐做法

```cpp
// 1. 优先使用 MakeShared 创建新对象
TSharedPtr<FMyClass> Ptr = MakeShared<FMyClass>(Param1, Param2);

// 2. 使用 auto 简化代码
auto PlayerData = MakeShared<FPlayerData>();

// 3. 在容器中存储智能指针
TArray<TSharedPtr<FEnemy>> Enemies;
Enemies.Add(MakeShared<FEnemy>());

// 4. 明确使用 TSharedRef 表示非空保证
TSharedRef<FConfig> Config = MakeShared<FConfig>().ToSharedRef();
```

### ❌ 不推荐做法

```cpp
// 1. 不要先 new 再 MakeShareable（如果不需要自定义删除器）
// ❌ 不好
FMyClass* Raw = new FMyClass();
TSharedPtr<FMyClass> Ptr = MakeShareable(Raw);

// ✅ 应该用
TSharedPtr<FMyClass> Ptr = MakeShared<FMyClass>();

// 2. 不要混用原始指针和智能指针
// ❌ 危险
FMyClass* Raw = new FMyClass();
TSharedPtr<FMyClass> Ptr1 = MakeShareable(Raw);
TSharedPtr<FMyClass> Ptr2 = MakeShareable(Raw);  // ❌ 双重删除！

// ✅ 正确
TSharedPtr<FMyClass> Ptr1 = MakeShared<FMyClass>();
TSharedPtr<FMyClass> Ptr2 = Ptr1;  // 共享所有权

// 3. 不要对非堆对象使用普通智能指针
// ❌ 危险
FMyClass StackObject;
TSharedPtr<FMyClass> Ptr = MakeShareable(&StackObject);  // ❌ 会尝试 delete 栈对象！

// ✅ 如果必须这样做，使用空删除器
TSharedPtr<FMyClass> Ptr = MakeShareable(&StackObject, [](FMyClass*){});
```

### 何时使用 MakeShareable

```cpp
// 场景 1：接管第三方库返回的指针
FMyClass* ExternalPtr = ThirdPartyLibrary::Create();
TSharedPtr<FMyClass> Ptr = MakeShareable(ExternalPtr);

// 场景 2：需要自定义删除器
FILE* File = fopen("data. txt", "r");
TSharedPtr<FILE> FilePtr = MakeShareable(File, [](FILE* f) { fclose(f); });

// 场景 3：与 UObject 系统集成（但通常不推荐）
UMyObject* UObj = NewObject<UMyObject>();
// 注意：UObject 有自己的 GC 系统，通常不应该用智能指针管理

// 场景 4：对象池
TSharedPtr<FPooledObject> Obj = MakeShareable(
    Pool.Allocate(),
    [this](FPooledObject* p) { Pool.Return(p); }
);
```

### 性能优化建议

```cpp
// 1. 批量创建时考虑预留空间
TArray<TSharedPtr<FMyClass>> Items;
Items.Reserve(1000);  // 避免多次重新分配
for (int32 i = 0; i < 1000; ++i)
{
    Items.Add(MakeShared<FMyClass>());
}

// 2. 使用 TSharedRef 避免空指针检查
TSharedRef<FMyClass> Ref = MakeShared<FMyClass>().ToSharedRef();
// 不需要检查空指针，编译器可以更好地优化

// 3. 在热路径避免不必要的智能指针转换
void ProcessData(const TSharedPtr<FData>& DataPtr)  // 使用 const 引用
{
    // 避免拷贝智能指针（拷贝会修改引用计数）
}

// 4. 考虑使用 TWeakPtr 打破循环引用
class FParent
{
    TSharedPtr<FChild> Child;  // 强引用
};

class FChild
{
    TWeakPtr<FParent> Parent;  // 弱引用，避免循环
};
```

---

## 常见问题

### Q1:  什么时候必须使用 MakeShareable？

**A:** 以下场景必须或推荐使用 `MakeShareable`：

```cpp
// 1. 需要自定义删除器
TSharedPtr<FILE> FilePtr = MakeShareable(File, CustomDeleter);

// 2. 接管已存在的原始指针
MyClass* ExistingPtr = GetPointerFromSomewhere();
TSharedPtr<MyClass> Ptr = MakeShareable(ExistingPtr);

// 3. 与 C API 集成
void* Handle = OpenResource();
TSharedPtr<void> Ptr = MakeShareable(Handle, CloseResource);
```

### Q2: MakeShared 比 MakeShareable 快多少？

**A:** 性能差异主要来自内存分配：

```cpp
// MakeShared:  1 次内存分配
// MakeShareable: 2 次内存分配 (new + 控制块)

// 理论速度提升:  ~30-40%
// 实际影响取决于：
// - 对象大小
// - 分配频率
// - 系统内存分配器性能

// 微基准测试示例：
// MakeShared:      ~20ns per object
// MakeShareable:  ~35ns per object
// 差异:  ~15ns (但在实际应用中可能不明显)
```

### Q3: 可以从 TSharedPtr 获取原始指针吗？

**A:** 可以，但要小心使用：

```cpp
TSharedPtr<MyClass> Ptr = MakeShared<MyClass>();

// 获取原始指针
MyClass* RawPtr = Ptr.Get();

// ⚠️ 注意事项：
// 1. 不要 delete 这个原始指针
// 2. 不要用这个原始指针创建新的 TSharedPtr
// 3. 确保 TSharedPtr 的生命周期长于原始指针的使用

// ✅ 安全用法：临时访问
void ProcessObject(MyClass* Obj);
ProcessObject(Ptr. Get());

// ❌ 危险用法
delete Ptr.Get();  // ❌ 双重删除
TSharedPtr<MyClass> Ptr2 = MakeShareable(Ptr.Get());  // ❌ 双重删除
```

### Q4: TSharedPtr 是线程安全的吗？

**A:** 部分线程安全：

```cpp
// ✅ 线程安全：引用计数的增减
TSharedPtr<MyClass> Ptr1 = MakeShared<MyClass>();
// 在多个线程中拷贝 Ptr1 是安全的
// 引用计数使用原子操作

// ❌ 非线程安全：访问对象内容
// 如果多个线程通过 TSharedPtr 访问同一对象，需要额外同步
FCriticalSection Mutex;
{
    FScopeLock Lock(&Mutex);
    Ptr1->ModifyData();  // 需要加锁保护
}

// ❌ 非线程安全：修改智能指针本身
// 在一个线程中修改 Ptr1 指向，同时另一个线程读取 Ptr1
TSharedPtr<MyClass> GlobalPtr;
// 线程 1
GlobalPtr = MakeShared<MyClass>();  // ⚠️ 需要同步
// 线程 2
if (GlobalPtr.IsValid()) { ...  }    // ⚠️ 需要同步
```

### Q5: 如何在类中使用智能指针？

**A:** 推荐模式：

```cpp
// 方式 1：直接持有 TSharedPtr
class FMyManager
{
public:
    void AddItem(TSharedPtr<FItem> Item)
    {
        Items.Add(Item);
    }
    
private:
    TArray<TSharedPtr<FItem>> Items;  // 持有所有权
};

// 方式 2：支持 TSharedFromThis（类似 std::enable_shared_from_this）
class FMyClass : public TSharedFromThis<FMyClass>
{
public:
    void RegisterSelf()
    {
        // 可以从 this 安全地创建 TSharedPtr
        TSharedPtr<FMyClass> Self = AsShared();
        SomeSystem->Register(Self);
    }
    
    void DoSomething()
    {
        // 也可以创建 TSharedRef
        TSharedRef<FMyClass> SelfRef = AsShared();
    }
};

// 使用方式 2
TSharedPtr<FMyClass> Obj = MakeShared<FMyClass>();
Obj->RegisterSelf();  // 内部可以安全获取 TSharedPtr
```

### Q6: TSharedPtr vs TUniquePtr 如何选择？

**A:** 根据所有权语义选择：

```cpp
// 使用 TUniquePtr（独占所有权）
// - 只有一个所有者
// - 不需要共享
// - 更轻量（无引用计数开销）
class FMyClass
{
    TUniquePtr<FImpl> Impl;  // 独占内部实现
};

// 使用 TSharedPtr（共享所有权）
// - 多个所有者
// - 需要共享访问
// - 生命周期不确定
TArray<TSharedPtr<FResource>> SharedResources;  // 多处持有

// 性能对比
// TUniquePtr: 几乎零开销，类似原始指针
// TSharedPtr: 引用计数开销，但提供共享语义
```

### Q7: 智能指针与 UObject 的 GC 系统如何配合？

**A:** 通常不混用：

```cpp
// ❌ 不推荐：用智能指针管理 UObject
UMyObject* UObj = NewObject<UMyObject>();
TSharedPtr<UMyObject> Ptr = MakeShareable(UObj);  // ⚠️ 可能与 GC 冲突

// ✅ 推荐：UObject 使用 GC 系统
UPROPERTY()
UMyObject* UObj;  // 由 GC 管理

// ✅ 推荐：非 UObject 类使用智能指针
TSharedPtr<FMyData> Data = MakeShared<FMyData>();

// 特殊情况：如果确实需要混用
// 使用空删除器，让 GC 负责实际删除
TSharedPtr<UMyObject> Ptr = MakeShareable(UObj, [](UMyObject*){
    // 不删除，让 GC 处理
});
```

### Q8: 如何调试智能指针相关的问题？

**A:** 常用调试技巧：

```cpp
// 1. 检查引用计数
TSharedPtr<MyClass> Ptr = MakeShared<MyClass>();
int32 RefCount = Ptr.GetSharedReferenceCount();
UE_LOG(LogTemp, Log, TEXT("RefCount: %d"), RefCount);

// 2. 检查是否唯一持有
if (Ptr.IsUnique())
{
    UE_LOG(LogTemp, Log, TEXT("I'm the only owner"));
}

// 3. 检查有效性
if (Ptr.IsValid())
{
    // 安全使用
}

// 4. 使用 TWeakPtr 检查对象是否还存活
TWeakPtr<MyClass> WeakPtr = Ptr;
// ...  稍后 ... 
if (TSharedPtr<MyClass> PinnedPtr = WeakPtr.Pin())
{
    // 对象还存活
}
else
{
    // 对象已被销毁
}

// 5. 启用调试日志（在析构函数中）
class FMyClass
{
public:
    ~FMyClass()
    {
        UE_LOG(LogTemp, Warning, TEXT("FMyClass destroyed:  %s"), *Name);
    }
};
```

### Q9: 循环引用如何处理？

**A:** 使用 TWeakPtr 打破循环：

```cpp
// ❌ 问题：循环引用导致内存泄漏
class FNode
{
public:
    TSharedPtr<FNode> Next;      // A -> B
    TSharedPtr<FNode> Previous;  // B -> A  (循环！)
};

TSharedPtr<FNode> A = MakeShared<FNode>();
TSharedPtr<FNode> B = MakeShared<FNode>();
A->Next = B;
B->Previous = A;  // 引用计数永远不会归零，内存泄漏！

// ✅ 解决：使用 TWeakPtr
class FNode
{
public: 
    TSharedPtr<FNode> Next;      // 强引用：持有所有权
    TWeakPtr<FNode> Previous;    // 弱引用：不持有所有权
};

TSharedPtr<FNode> A = MakeShared<FNode>();
TSharedPtr<FNode> B = MakeShared<FNode>();
A->Next = B;
B->Previous = A;  // ✅ 不会造成循环

// 使用弱引用
if (TSharedPtr<FNode> Prev = B->Previous.Pin())
{
    // 安全访问
}

// 典型的父子关系
class FParent
{
    TArray<TSharedPtr<FChild>> Children;  // 父持有子（强引用）
};

class FChild
{
    TWeakPtr<FParent> Parent;  // 子引用父（弱引用）
};
```

---

## 快速参考

### 使用决策树

```
需要创建智能指针？
    │
    ├─ 创建新对象？
    │   │
    │   ├─ 需要自定义删除器？
    │   │   ├─ 是 → 使用 new + MakeShareable(ptr, deleter)
    │   │   └─ 否 → 使用 MakeShared<T>() ✅ 推荐
    │   │
    │   └─ 已有原始指针？
    │       ├─ 需要自定义删除器 → MakeShareable(ptr, deleter)
    │       └─ 不需要 → MakeShareable(ptr)
    │
    └─ 需要共享所有权？
        ├─ 是 → TSharedPtr<T>
        ├─ 否（独占） → TUniquePtr<T>
        └─ 弱引用（打破循环）→ TWeakPtr<T>
```

### 代码速查表

```cpp
// === 创建 ===
auto Ptr1 = MakeShared<MyClass>();                          // 创建新对象（推荐）
auto Ptr2 = MakeShareable(new MyClass());                   // 包装原始指针
auto Ptr3 = MakeShareable(rawPtr, [](auto* p) { delete p; }); // 自定义删除器

// === 检查 ===
if (Ptr. IsValid()) { }           // 检查是否非空
if (Ptr.IsUnique()) { }          // 检查是否唯一持有
int32 Count = Ptr.GetSharedReferenceCount();  // 获取引用计数

// === 访问 ===
MyClass* Raw = Ptr.Get();        // 获取原始指针
MyClass& Ref = *Ptr;             // 解引用
Ptr->Method();                   // 调用成员函数

// === 转换 ===
TSharedRef<MyClass> Ref = Ptr.ToSharedRef();  // 转为 TSharedRef（必须非空）
TWeakPtr<MyClass> Weak = Ptr;                 // 转为弱指针
TSharedPtr<MyClass> Pinned = Weak.Pin();      // 弱指针升级为强指针

// === 重置 ===
Ptr. Reset();                     // 释放所有权，设为 null
Ptr = nullptr;                   // 同上
```

---

## 总结

### 核心要点

1. **优先使用 MakeShared**
   - 性能最优（单次内存分配）
   - 适用于 99% 的场景
   - 不支持自定义删除器

2. **必要时使用 MakeShareable**
   - 接管已存在的指针
   - 需要自定义删除器
   - 集成第三方代码

3. **设计原理**
   - MakeShared 牺牲灵活性换取性能
   - MakeShareable 牺牲性能换取灵活性
   - 两者分离使性能特征更明确

4. **最佳实践**
   - 避免混用原始指针和智能指针
   - 使用 TWeakPtr 打破循环引用
   - UObject 使用 GC，普通类使用智能指针
   - 优先使用 const 引用传递智能指针

### 记住这个原则

> **"Make it work, make it right, make it fast"**
> 
> - 先让代码工作（使用智能指针避免内存泄漏）
> - 再让代码正确（选择合适的所有权语义）
> - 最后优化性能（MakeShared vs MakeShareable）

---

## 参考资源

- [UE 官方文档 - Smart Pointers](https://docs.unrealengine.com/en-US/ProgrammingAndScripting/ProgrammingWithCPP/SmartPointerLibrary/)
- [UE 源码](https://github.com/EpicGames/UnrealEngine) - `Engine/Source/Runtime/Core/Public/Templates/SharedPointer.h`
- C++ Core Guidelines - [R.20: Use unique_ptr or shared_ptr to represent ownership](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r20-use-unique_ptr-or-shared_ptr-to-represent-ownership)

---

**文档版本**:  1.0  
**最后更新**: 2025-12-14  
**作者**:  Copilot  
**适用于**:  Unreal Engine 4.x / 5.x