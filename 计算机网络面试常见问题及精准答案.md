# 计算机网络面试常见问题及精准答案

## 一、网络分层模型

### 1. OSI七层模型 vs TCP/IP四层模型

| OSI七层 | TCP/IP四层 | 主要协议 | 功能 |
|---------|------------|----------|------|
| 应用层 | 应用层 | HTTP, FTP, DNS, SMTP | 为应用程序提供网络服务 |
| 表示�� | ↑ | — | 数据格式转换、加密 |
| 会话层 | ↑ | — | 建立、管理会话 |
| 传输层 | 传输层 | TCP, UDP | 端到端可靠/不可靠传输 |
| 网络层 | 网络层 | IP, ICMP, ARP | 路由选择、逻辑寻址 |
| 数据链路层 | 网络接口层 | Ethernet, PPP | 帧传输、MAC寻址 |
| 物理层 | ↑ | — | 比特流传输 |

### 2. 每层传输的数据单位

| 层 | 数据单位 |
|----|----------|
| 应用层 | 报文（Message） |
| 传输层 | 段（Segment）/数据报（Datagram） |
| 网络层 | 分组/包（Packet） |
| 数据链路层 | 帧（Frame） |
| 物理层 | 比特（Bit） |

---

## 二、TCP与UDP

### 1. TCP与UDP的区别

| 特性 | TCP | UDP |
|------|-----|-----|
| 连接方式 | 面向连接 | 无连接 |
| 可靠性 | 可靠（确认、重传） | 不可靠 |
| 顺序保证 | 保证有序 | 不保证 |
| 传输效率 | 较低 | 较高 |
| 头部开销 | 20字节 | 8字节 |
| 流量控制 | 有（滑动窗口） | 无 |
| 拥塞控制 | 有 | 无 |
| 适用场景 | 文件传输、网页、邮件 | 视频通话、游戏、直播、DNS |

### 2. TCP三次握手

```
客户端                              服务端
   |                                   |
   |-------- SYN (seq=x) ------------>|  SYN_SENT
   |                                   |  SYN_RCVD
   |<----- SYN+ACK (seq=y,ack=x+1) ---|
   |                                   |
   |-------- ACK (ack=y+1) ---------->|  ESTABLISHED
   |                                   |  ESTABLISHED
```

| 握手 | 发送方 | 报文 | 目的 |
|------|--------|------|------|
| 第一次 | 客户端 | SYN=1, seq=x | 请求建立连接 |
| 第二次 | 服务端 | SYN=1, ACK=1, seq=y, ack=x+1 | 同意连接，确认收到 |
| 第三次 | 客户端 | ACK=1, ack=y+1 | 确认收到，连接建立 |

**为什么需要三次握手？**
- 确认双方的发送和接收能力
- 防止已失效的连接请求到达服务端造成资源浪费

### 3. TCP四次挥手

```
主动方                              被动方
   |                                   |
   |-------- FIN (seq=u) ------------>|  FIN_WAIT_1
   |                                   |  CLOSE_WAIT
   |<------- ACK (ack=u+1) -----------|
   |                                   |  FIN_WAIT_2
   |<------- FIN (seq=w) -------------|  LAST_ACK
   |                                   |
   |-------- ACK (ack=w+1) ---------->|  TIME_WAIT
   |                                   |  CLOSED
   |         (等待2MSL)                |
   |              CLOSED               |
```

| 挥手 | 发送方 | 报文 | 目的 |
|------|--------|------|------|
| 第一次 | 主动方 | FIN=1 | 请求断开连接 |
| 第二次 | 被动方 | ACK=1 | 确认收到断开请求 |
| 第三次 | 被动方 | FIN=1 | 被动方也请求断开 |
| 第四次 | 主动方 | ACK=1 | 确认断开，等待2MSL后关闭 |

**为什么需要四次挥手？**
- TCP是全双工，双方都需要独立关闭各自的发送通道
- 被动方收到FIN后可能还有数据要发送

**为什么TIME_WAIT要等待2MSL？**
- 确保最后的ACK能到达被动方
- 让本次连接的所有报文在网络中消失，防止影响新连接

### 4. TCP如何保证可靠传输

| 机制 | 说明 |
|------|------|
| **序列号** | 每个字节都有唯一序号，保证有序 |
| **确认应答（ACK）** | 接收方确认已收到的数据 |
| **超时重传** | 超时未收到ACK则重发 |
| **校验和** | 检测数据是否损坏 |
| **滑动窗口** | 流量控制，防止发送过快 |
| **拥塞控制** | 慢启动、拥塞避免、快重传、快恢复 |

### 5. TCP拥塞控制算法

| 阶段 | 说明 |
|------|------|
| **慢启动** | 拥塞窗口从1开始指数增长 |
| **拥塞避免** | 达到阈值后线性增长 |
| **快重传** | 收到3个重复ACK立即重传 |
| **快恢复** | 快重传后不进入慢启动，直接进入拥塞避免 |

### 6. 重要状态解释

| 状态 | 说明 |
|------|------|
| **TIME_WAIT** | 主动关闭方等待2MSL，确保ACK送达 |
| **CLOSE_WAIT** | 被动关闭方等待应用层处理完毕 |
| **SYN_FLOOD** | 攻击方式，发送大量SYN不完成握手 |

---

## 三、HTTP与HTTPS

### 1. HTTP的特点

- 基于**请求/响应**模型
- **无状态**协议（每次请求独立）
- 默认端口：**80**
- 应用层协议，基于TCP

### 2. HTTP与HTTPS的区别

| 特性 | HTTP | HTTPS |
|------|------|-------|
| 安全性 | 明文传输，不安全 | 加密传输，安全 |
| 端口 | 80 | 443 |
| 证书 | 不需要 | 需要SSL/TLS证书 |
| 性能 | 较快 | 有握手开销，略慢 |
| 加密层 | 无 | SSL/TLS |

### 3. HTTPS工作原理

```
1. 客户端发起HTTPS请求
2. 服务端返回证书（含公钥）
3. 客户端验证证书合法性
4. 客户端生成随机对称密钥，用公钥加密后发送
5. 服务端用私钥解密获得对称密钥
6. 双方使用对称密钥加密通信
```

### 4. HTTP请求方法

| 方法 | 说明 | 幂等性 |
|------|------|--------|
| **GET** | 获取资源 | ✅ 是 |
| **POST** | 提交数据 | ❌ 否 |
| **PUT** | 更新资源（完整替换） | ✅ 是 |
| **PATCH** | 更新资源（部分更新） | ❌ 否 |
| **DELETE** | 删除资源 | ✅ 是 |
| **HEAD** | 只获取响应头 | ✅ 是 |
| **OPTIONS** | 查询支持的方法 | ✅ 是 |

### 5. GET与POST的区别

| 区别点 | GET | POST |
|--------|-----|------|
| 参数位置 | URL中（查询字符串） | 请求体中 |
| 安全性 | 较低（参数可见） | 较高 |
| 长度限制 | 有（URL长度限制） | 无明显限制 |
| 幂等性 | 幂等 | 非幂等 |
| 缓存 | 可被缓存 | 一般不缓存 |
| 书签 | 可保存为书签 | 不可以 |
| 历史记录 | 保留参数 | 不保留 |

### 6. HTTP状态码

| 分类 | 范围 | 说明 |
|------|------|------|
| 1xx | 100-199 | 信息性状态码 |
| 2xx | 200-299 | 成功 |
| 3xx | 300-399 | 重定向 |
| 4xx | 400-499 | 客户端错误 |
| 5xx | 500-599 | 服务器错误 |

**常见状态码**：

| 状态码 | 含义 |
|--------|------|
| 200 | OK，请求成功 |
| 201 | Created，资源创建成功 |
| 204 | No Content，成功但无返回内容 |
| 301 | 永久重定向 |
| 302 | 临时重定向 |
| 304 | Not Modified，使用缓存 |
| 400 | Bad Request，请求语法错误 |
| 401 | Unauthorized，未认证 |
| 403 | Forbidden，禁止访问 |
| 404 | Not Found，资源不存在 |
| 500 | Internal Server Error，服务器内部错误 |
| 502 | Bad Gateway，网关错误 |
| 503 | Service Unavailable，服务不可用 |
| 504 | Gateway Timeout，网关超时 |

### 7. Cookie与Session

| 特性 | Cookie | Session |
|------|--------|---------|
| 存储位置 | 客户端 | 服务端 |
| 安全性 | 较低 | 较高 |
| 大小限制 | 约4KB | 取决于服务端 |
| 生命周期 | 可设过期时间 | 依赖SessionID |
| 跨域 | 受同源策略限制 | 不涉及 |

### 8. HTTP版本演进

| 版本 | 特点 |
|------|------|
| **HTTP/1.0** | 短连接，每次请求新建TCP连接 |
| **HTTP/1.1** | 长连接（Keep-Alive），管道化（有队头阻塞） |
| **HTTP/2** | 多路复用、头部压缩、服务器推送、二进制帧 |
| **HTTP/3** | 基于QUIC（UDP），解决TCP队头阻塞 |

---

## 四、DNS

### 1. DNS的作用

将**域名**解析为**IP地址**

### 2. DNS解析过程

```
1. 浏览器缓存
2. 操作系统缓存（hosts文件）
3. 本地DNS服务器
4. 根DNS服务器
5. 顶级域DNS服务器（如.com）
6. 权威DNS服务器
7. 返回IP地址，逐级缓存
```

### 3. DNS查询方式

| 方式 | 说明 |
|------|------|
| **递归查询** | 客户端只发一次请求，DNS服务器负责完成全部查询 |
| **迭代查询** | DNS服务器返回下一级服务器地址，客户端继续查询 |

---

## 五、其他高频问题

### 1. 浏览器输入URL后发生了什么？

```
1. URL解析
2. DNS解析（域名 → IP）
3. 建立TCP连接（三次握手）
4. 发送HTTP/HTTPS请求
5. 服务器处理请求并返回响应
6. 浏览器解析HTML、加载资源
7. 渲染页面
8. 断开TCP连接（四次挥手）
```

### 2. ARP协议

- **作用**：将IP地址解析为MAC地址
- **工��范围**：局域网内
- **过程**：广播ARP请求，目标主机单播回复

### 3. ICMP协议

- **作用**：网络诊断和错误报告
- **常用命令**：`ping`（测试连通性）、`traceroute`（追踪路由）

### 4. 什么是跨域？如何解决？

**跨域**：浏览器同源策略限制不同源（协议、域名、端口不同）的请求

**解决方案**：

| 方案 | 说明 |
|------|------|
| **CORS** | 服务端设置`Access-Control-Allow-Origin`响应头 |
| **JSONP** | 利用`<script>`标签不受同源策略限制（仅支持GET） |
| **代理服务器** | 同源服务器转发请求 |
| **WebSocket** | 不受同源策略限制 |

### 5. 正向代理与反向代理

| 类型 | 代理对象 | 作用 |
|------|----------|------|
| **正向代理** | 客户端 | 代替客户端访问服务器（如VPN） |
| **反向代理** | 服务端 | 代替服务器接收请求（如Nginx负载均衡） |

### 6. CDN（内容分发网络）

- **作用**：将内容缓存到离用户最近的节点，加速访问
- **原理**：DNS解析时返回最近CDN节点IP

### 7. 对称加密与非对称加密

| 类型 | 密钥 | 速度 | 安全性 | 应用 |
|------|------|------|--------|------|
| **对称加密** | 同一个密钥 | 快 | 密钥分发困难 | AES, DES |
| **非对称加密** | 公钥+私钥 | 慢 | 安全 | RSA, ECC |

### 8. 常见网络攻击与防御

| 攻击类型 | 说明 | 防御 |
|----------|------|------|
| **SYN Flood** | 发送大量SYN不完成握手 | SYN Cookie、限流 |
| **XSS** | 注入恶意脚本 | 输入过滤、CSP |
| **CSRF** | 伪造用户请求 | Token验证、SameSite Cookie |
| **SQL注入** | 注入恶意SQL语句 | 参数化查询、输入验证 |
| **DDoS** | 分布式拒绝服务 | CDN、流量清洗 |

---

## 六、Socket编程基础

### 1. Socket通信流程

**TCP服务端**：
```
socket() → bind() → listen() → accept() → recv()/send() → close()
```

**TCP客户端**：
```
socket() → connect() → send()/recv() → close()
```

### 2. 常见Socket选项

| 选项 | 说明 |
|------|------|
| `SO_REUSEADDR` | 允许重用处于TIME_WAIT状态的地址 |
| `SO_KEEPALIVE` | 保持连接存活，检测死连接 |
| `TCP_NODELAY` | 禁用Nagle算法，减少延迟 |